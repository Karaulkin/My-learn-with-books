***Лямбда-выражения в C++* — это анонимные функции, которые позволяют писать инлайн-выражения прямо там, где они используются. С их помощью можно легко определять функции обратного вызова, передавать их в функции высшего порядка или использовать для инициализации функциональных объектов.**

#### Лямбда-выражения

##### C++14

Лямбда-выражение в C++14 можно объявить следующим образом:

``` C++
auto myLambda = []() { /* тело лямбды */ };
```

`[]` называется лямбда-интродуктором и указывает на захват переменных из окружающего контекста. Скобки после интродуктора могут содержать параметры, как у обычной функции, а фигурные скобки ограничивают тело лямбды.

[Лямбда-выражения в C++](https://learn.microsoft.com/ru-ru/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170)

> [!NOTE] Простыми словами
> Не совсем понял для чего нужно `[]`
> В `()` по факту служит как передачи параметров для *функции лямды*
> `{...}` является ==телом лямды==
   *Погуглить на ютубе*

*Захват переменных позволяет* лямбда-выражениям использовать данные из окружающего контекста. Доступны следующие способы захвата:

- `[=]` захватывает все переменные из области видимости по значению.
- `[&]` захватывает все переменные по ссылке.
- `[this]` захватывает указатель `this` для доступа к членам класса.
- `[var]` или `[&var]` захватывает конкретную переменную по значению или по ссылке соответственно.
###### Простой пример:
``` C++
std::vector<int> nums = {1, 2, 3, 4, 5};
std::for_each(nums.begin(), nums.end(),
	[](int n) { std::cout << n << " "; });
```

> [!Question] Что делает Code?
>Код выводит все элементы вектора, используя лямбда-выражение в качестве функции обратного вызова.

> [!Question] Что делает `std::for_each`?
> `for_each` в С++ — это алгоритм, позволяющий выполнять обход массивов и массивоподобных структур. В переводе с английского название означает "для каждого", т. е. для каждого элемента (подразумевается, что выполнять что-то). Название алгоритма выбрано таким образом, что алгоритм как будто просит придать смысл своего существования. Что-то, что нужно будет выполнить, можно задавать с помощью отдельной функции (либо функтора), либо прям по месту с помощью лямбда-выражения. В очень старых компиляторах алгоритмов нет, поэтому и `for_each` в них использовать не получится.

>[!info] 
>Поскольку в первую очередь алгоритм выполняет обход элементов, то и первым примером использования будет обход обычного массива.
>- `for_each` — это агоритм для обхода массива или массивоподобной структуры.
>- `for_each` принимает три параметра: начало и конец обходимого набора данных и указатель на функцию, либо лямбда-выражение или функтор, выполняющие основную обработку обходимымых элементов.

*Захват переменных:*

```C++
int multiplier = 5;
auto multiply = [multiplier](int n) { return n * multiplier; };std::cout << multiply(10);
// Выведет 50
```

>[!info] Info
>Лямбда захватывает переменную `multiplier` по значению и использует ее для умножения входного параметра.

C++14 позволяет инициализировать переменные непосредственно в лямбда-интродукторе:

```C++
auto lambda = [x = 42]() { return x; };
```

`x` инициализируется значением `42` и захватывается лямбда-выражением.

Пример с автоматическим выводом типов:

```C++
std::vector<int> nums = {1, 2, 3, 4, 5};auto evenCount = std::count_if(nums.begin(), nums.end(), [](int n) { return n % 2 == 0; });
std::cout << "Количество четных чисел: " << evenCount << std::endl;
```

>[!cite]
Лямбда-выражение используется для подсчета четных чисел в векторе, и тип возвращаемого значения выводится автоматически.

Пример с инициализацией захваченных переменных:

```C++
auto adder = [value = 10](int x)
{
	return x + value;
};
std::cout << adder(5); // 15
```

>[!cite]
Лямбда-выражение захватывает и иницилизирует переменную `value`, которая затем используется для добавления к переданному аргументу.

##### Нововведения в C++17

Здесь появилась крутая фича с захватом `*this` в лямбда-выражениях. Можно захватывать текущий объект по значению, мастхев при работе с классами или объектами

Рассмотрим класс, в котором нужно использовать лямбда-выражение, захватывающее все локальные переменные по значению и текущий объект класса тоже по значению:

```C++
class MyClass {
public:
	int value = 10;
    void printValue() 
    {
		auto lambda = [=, *this]()
		{ 
			std::cout << "Value: " <<
			 value << std::endl;
		};        
		lambda();    
	}
};

int main()
{    
	MyClass obj;
	obj.printValue();
	// Выведет: Value: 10
}
```

Лямбда захватывает текущий объект `*this` по значению и так можно использовать члены класса внутри лямбды.

В C++17 лямбды теперь могут быть выполнены на этапе компиляции(`constexpr)`:

```C++
constexpr auto square = [](int n) constexpr
{return n * n;};

int main()
{
	constexpr int result = square(5);
	static_assert(result == 25, "The result must be 25");
}
```

>[!cite]
`square` является `constexpr` лямбда-выражением, а так его можно вычислить на этапе компиляции.

Также C++17 наконец стали довольно часто юзать stl. Вообще, можно было юзать и начиная с версии 14, но только в 17 версии это обрело свою массовость:

```C++
#include <algorithm>
#include <iostream>
#include <vector>
int main()
{    
	std::vector<int> numbers = {1, 2, 3, 4, 5};
	// auto в параметрах лямбда-выражения
	auto isEven = [](auto n) { return n % 2 == 0;  };    
	auto it = std::find_if(numbers.begin(), numbers.end(), isEven);
		if (it != numbers.end())
		{
			std::cout << "Первое четное число: " <<    *it << std::endl;
		}
}
```

Параметр `auto` позволяет его использовать с любым типом, поддерживающим операцию `%`.

##### C++20

C версии C++20 лямбду можно использовать вместе с шаблонами:

```C++
auto genericLambda = []<typename T>(T x) 
{
	std::cout << x << std::endl;
};
genericLambda(10);    
// воркает с intgenericLambda("Test"); // с const char*
```

Концепты в C++20 позволили реализовать строгую типизацию и сделать более понятные требования к шаблонам:

```C++
#include <concepts>
#include <iostream>
template<typename T>
concept Addable = requires(T a, T b)
{
	{ a + b } -> std::convertible_to<T>;
};
auto add = []<Addable T>(T a, T b)
{
	return a + b;
};
int main() 
{
	std::cout << add(1, 2) << std::endl; //  3    
	// std::cout << add("a", "b") << std::endl; 
	// ошибка компиляции, так как "a" и "b" не удовлетворяют концепту Addable
}
```