---
tags:
  - Code
  - CPP
моя оценка: 
прочитал страниц: 
создал заметку: 2024-05-05
начал читать: 16 июня 2024
author: Джон Лоспинозо
цена книги: 2'600
прочитал n-раз:
---
### Резюме
==Добавьте краткие итоги и свои впечатления о книге. Что нового вы узнали и какие ее особенности?==

***
## Пользовательские типы

*Пользовательские типы -* это типы, котороые пользователь может определить самостоятельно. Вот три основные категории пользовательских типов:
- Перечисления. Простейший из определяемых пользователем типов. Значение, которые может принимать перечисление, ограничены набором возможных значений.

> [!cite] 
> Перечисления отлично подходят для моделирования категориальных понятий

- Классы. Гибко объеденяет данные и функции.
- Объеденения. Специализированный пользовательский тип. Все члены объеденения  разделяют одну и ту же ячейку памяти.

>[!cite]
>Объеденения опасны и ими легко злоупотребить

#### Перечисления 

```cpp
enum class
```

Класс перечисления, содержащий все расы из "Семиевения" Нила Стивенсона

```cpp
enum class Race {
	Dinan,
	Teklan,
	Ivyn,
	Aidan,
	...
}
```

Для инициализации переменной перечисления

```cpp
Race langobard_race = Race::Aidan
```

#### Оператор switch

```cpp
switch (Условие) {  
    case (Условие): {  
		-- действие      
    } break;  
    case (Условие): {  
	    -- действие     
    } break;  
    case (Условие): {  
	    -- действие 
    } break;  
    case (Условие): {  
        -- действие  
    } break; 
    default: {
    // ...
    } 
}
```

### Простые классы - struct

> Информация не поменялась осталось для поддержки С

### Объеденения

`union`

Может быть обозначенно одим из полей включённых в `union`

> может быть вызванна ошибка так как все поля *объеденения* хранятся в одной области памяти 

### Полнофункциональные классы С++

Инкапсуляция достигается в С++ путём добавления методов и элементов управления доступом к определениям классов.

#### Методы

*Методы* являются функциями-членами. Они создают явную связь между классом, его членами данных и некоторым кодом. Определение метода так же просто, как добаление функции в определение класса. Методы имеют доступ ко все членнам класса.

#### Контороль доступа

*Контоль доступа* ограничевает доступ к членам класса. Основные средства контолья доступа -  это *публичные* и *приватные* поля.

Нет никакой разницы в class и struct, кроме конторля доступа по умолчанию. В class он приватный, в struct публичный.

Чтобы пользователь не взаимодействовал и полями класса на прямую существуют *сетттеры* и *геттеры*. С помощью этих приёмов можно добавлять проверки.

Конструкторы инициализируют объекты и применяют инварианты классов (Инвариантом класса называют - свойство класса, которое всегда истинно(то есть никгда не изменяется)) с самого начала жизни объектов.

#### Конструктор

*Конструктор* - это специальный метод со специальным объявлениями. Не указывает тип возвращаемого значения, а его имя соотвествует имени класса.

### Инициализация

То как объекты воплощаются в жизнь

#### Инициализация базового типа нулевым значением

```cpp
int a = 0;
int b{};
int c = {};
int b; // возможно 0
```
#### Инициализвация базового типа произвольным значением

```cpp
int a = 42;
int b{42};
int c = {42};
int b(42);
```

#### Инициализация классов POD 

```cpp
#include <cstdint>  
  
struct podStruct {  
    uint64_t a;  
    char b[256];  
    bool c;  
};  
  
int main() {  
    podStruct initialized_pod1{}; // все поля равны нуль  
    podStruct initialized_pod2 = {}; // все поля равны нуль  
  
    podStruct initialized_pod3{42, "Hi"}; // Поля a и b заданы, с = 0  
    podStruct initialized_pod4{42, "Hi", true}; // Все поля заданы  
}
```

>[!bug]
>```cpp
>podStruct initialized_pod = 0;
>```

#### Инициализация POD произвольными значениями

```cpp
podStruct initialized_pod3{42, "Hi"}; // Поля a и b заданы, с = 0  
```

Инициализацию можно пропускать только справа налево.

#### Инициализация массивов 

```cpp
int main() {
	int array_1[]{1, 2, 3}; // массив размером 3: 1, 2, 3.
	int array_1[5]{}; // массив размером 5: 0, 0, 0, 0, 0.
	int array_1[5]{1, 2, 3}; // массив размером 5: 1, 2, 3, 0, 0.
	int array_1[5]; //  массив размером 5: неинициализированные значения.
}
```

### Полнофункциональные классы

В отличии от базовых типов и POD полнофункциональные классы всегда инициализируются. Другими словами, один из полнофункциональных конструкторов класса всегда вызовется во время инициализации. Какой конструктор вызывается зависит от аргументовзаданных во время инициализации.

Если прибегать к инициализации класса таким образом:

```cpp
Taxanomist t8();
```

Выглядит как объявление функции, и это так и есть. Из-за некоторых тайных правил синтаксического анализа языка мы объявили компилятору, что функция `t8`, которую ещё предстоит определить, не принимает аргументов и возвращает объект типа `Taxanomist`.

>[!bug]
>Это хорошо известная проблема называется *самым неприятным анализом*, и это главня причина, по которой сообщество С++ добавило в язык синтаксис с фигурной инициализацией.

Правильно работать будет вот так:

```cpp
class Taxanomist {  
  
};  
  
int main() {  
    Taxanomist t1;  // вызывается констр без параметров
    Taxanomist t2{ 'c' };  // конструктор с инициализацией
    Taxanomist t3('g');  // конструктор с инициализацией
    Taxanomist t4 = {'d'};  // конструктор с инициализацией
    Taxanomist t5{};  // вызывается конструктор поумолчанию
}
```

*Сужение преобразований* - вот ещё одна проблема.

#### Сужение преобразований

```cpp
float a{1};
float b{2};
int narrowed_result(a/b); // потенциально опасное сужение преобразований
int result{a/b}; // компилятор выведет исключение
```

#### Инициализация членнов класса

```cpp
class John {
	bool gold = true;
	int year{ 1970 };
	char key[8] = {"x-rated"};
}
```

#### Приготовтесь

>[!note] Простое правило!
>Везде использовать вариант инициализации с фигурными скобками.
>Вариант инциализации с фигурными скобками  работает, как и предпологается, почти везде, и они вызывают меньше всего сюрпризов. По этой причине такая реализация называется *равномерной инициализацией*.

#### Деструктор

Определение деструктора необязательно. Если вы решитереализовать деструктор, он не должен принимать никаких параметров. Примеры действий, которые можно предпринимать в деструкторах, включают освобождение файловых дескрипторов, очистку сетевых сокетов и освобождение динамической памяти.

## Ссылочные типы

*Ссылочные типы* хранят адреса памяти объектов. Эти типы обеспечивают эффективное программирование и многие из них имеют элегантный дизайн.
В этой главве будет рассказанно про ссылки и указатели, а так же по ходк дела разберём *this, cons и auto.*

### Указатели

*Указатели* - это основной механизм для обращения к адресам памяти. Указатели кодируют две части объекта его адресс и тип объекта.

Чтобы объявить указатель нужно добавить `*` к указанному типу.

#### Обращение к переменным

Адресс переменной можно получить, предварительно добавив *оператор вычисления адресса(&)*.

```cpp
int getty{};
int* getty_addres = &getty;
```

Вывод адресса должен каждый раз отличаться это называется - *случайны распредением адрессного пространства*.

#### Разыменование указателя

*Оператор разыменования* (_*_) - это унарный оператор, обращающийся к объекту, на который ссылается указатель.

#### Оператор "стрелка"

*Оператор "стрелка"* (->) выполняет:
- разыменование указателя;
- получает доступ к членну указанного объекта.

Этот можно использовать, чтобы уменьшить *условные помехи*, то есть сопротивление, которое программист испытывает, выражая свое намерение в коде, при обработке указателей на классы.

```cpp
#include <iostream>  
  
class ClockOfTheLongNow {  
    // ...  
};  
  
int main() {  
    ClockOfTheLongNow clock;  
    ClockOfTheLongNow* clock_ptr = &clock;  
    clock_ptr->set_year(2020);  
}
```

#### Указатель и массив

```cpp
int key[]{1, 2, 3};
int* key_ptr = key; // указывает на 1
```

#### Обработка превращения

Массивы часто передаются двумя параметрами:
- указатель на первый элемент массива.
- длинна массива (sizeof(arr) / sizeof(arr[1]))

#### Арифметика указателей

*Арифметика указателей*, набор правил сложения и вычитания указателей, обеспечивает альтернативный подход. При добавлении или вычитании целых чисел из указателей компилятор вычисляет правильное смещение в байтах, используя размер указанного типа.

```cpp
College* third_college_ptr = &oxford[2];
// эквивалентны
College* third_college_ptr = oxford + 2;
```

#### Опасность указателей

Указателю невозможно преобразовать в массив, что хорошо. Это вам не понадобится,и, кроме того, компилятору вообще не удастся востановить размер массива. Но компилятор не сможет уберечь от:

##### Переполнение буфера

>[!bug]
>Часто такая ошибка возникает, когда мы пишим за нашими разделами(пределами) памяти.

Такое называется *неопределённым поведением*.
##### Связь между скобками и арифметикой указателей

Одно и тоже:

```cpp
*(lower + 3) = 'd';
lower[3] = 'd';
```
##### Указатель void и std::byte

Иногда указанный тип не имеет значения. В таких ситуациях используется *указатель на void* - _void*_. ==Указатели на воид нельзя разыменовывать==. Поскольку тип, на который ссылается указатель, был удалён, разыменование не имеет смысла (напомним, что набор для значений void пуст). Поэтому С++ запрещает арифметику указателей.

В других случиях необходимо взаимодействовать с необработанной памятью на уровень байтов. Примеры включают низкоуровневые операции, такие как копирование необработанных данных между файлами и памятью, шифрование и сжатие. Для таких случаев используют std::byte, потому что арифметические операции для void отключены.
##### nullptr и логические выражения

Указатели могут быть помеченны значением *nullptr* - это можно использовать например, чтобы указать, что больше не осталось памяти или произошла какая-то ошибка.

Указатель неявно преобразуется в bool, тогда nullptr - false, а любое другое значение это true.

### Ссылки

Ссылки более безопасное и более удобная версия указателя.
- они не могут быть повтороно установленны;
- не может быть приравненна нулю.

```cpp
#include <cstdio>  
  
class ClockOfTheLongNow {  
  
};  
  
void add_year(ClockOfTheLongNow& clock) {  
    clock.set_year(clock.get_year + 1); // В операторе разыминования  
                                        // нет необходимости}  
  
int main() {  
    ClockOfTheLongNow clock;  
    add_year(clock);  
}
```

#### Использование указателей и ссылок

Указатели и ссылки в значительной степени взаимосвязанны, но и те и другие имеют компромиссное решение. Если нужно изменить значение ссылочного типа, - используйте указатель.
(Например связный список)

#### Использование ссылок

Указатели обеспечивают большую гибкость, но эта гибкость достигается за счёт безопасности. Если вам не нжна шибкость переопределения и nullptr, ссылки являются подходящим ссылочным типом.


>Ссылки не могут быть перепресвоины

```cpp
#include <iostream>  
  
  
int main() {  
    int original = 100;  
    int& ref = original;  
  
    std::cout << "Orig: " << original << std::endl;  
    std::cout << "Ref: " << ref << std::endl;  
  
    int new_val = 200;  
    ref = new_val;  
  
    std::cout << "Orig: " << original << std::endl;  
    std::cout << "New: " << new_val << std::endl;  
    std::cout << "Ref: " << ref << std::endl;  
}
```

>[!bug] Output
> Orig: 100
> Ref: 100
> 
> Orig: 200
  New: 200
  Ref: 200

#### Указатели this

Полезен если при выполнении метода нужно получить доступ к *текущему объекту*, который является объектом выполняемого метода.

Может понадобиться, если нужно явно показать, к какому месту идёт обращение.

Например при одинаковыз названиях переменных.

#### Правильное использование const

Ключевое слово const примерно означает "я обещаю не меняться". Это механизм безопасности, который предотвращает изменения переменных-членов. const будет использоваться в определениях функций и классов, чтобы указать, что переменная(обычно ссылка или указатель) не будет измененна функцией или классом.  

##### Аргумент const

Маркировка ключевым словом const исключает его модификации в рамках функции. Указатель или ссылка const педставляет эфективный механизм для передачи объекта в функцию только для чтения.

##### Метод const

Маркировка метода const означает, что вы обещаете не изменять текущее состояние объектов в методе const. Другими словами, эти методы предназначены только для чтения.

```cpp
class CloclOfTheLongNow {
	int year;
public:
	int get_year const {
		return year;
	}
}
```

Держатели постоянных ссылок и указателей не могут вызывать методы, которые не являются поятоянными, поскольку методы, которые не являются поятоянными, могут изменять состояние объектов.

```cpp
bool is_leap_year(const CloclOfTheLongNow& clock) {
	if (clock.get_year() > 0) return true;
	else return false;
}
```

Если бы get_year не бы помечен как const, то код сверху не скомпилировался бы, поскольку clock является const-ссылкой и не может быть изменена в is_leap_year.

##### Переменные-члены const

Можно обозначить переменные-члены как постоянные, добавив ключевое слово const к типу члена. Переменные-членны const не могут быть изменены после инициализации.

```cpp
struct Avout {
	const char* name = "Alisa";
	CloclOfTheLongNow apeart;
}
```

Член name является постоянным, что означает, что указанное значение для чтения. С другой стороны apeart не является const.

Кончно, постоянная ссылка Avout не может быть изменена, поэтому обычные правила будут по-прежнему применяться к apeart.

Иногда требуется безопасность маркировки переменной-члена как const, но также хотелось бы инициализировать член с помощью фргументов, передаваемых в конструктор. Для этого используется списки инициализаторов членнов.
##### Списки инициализаторов членов

писки инициализаторов членов - это основной механизм инициализации членнов класса. Чтобы объявить список инициализации членов, поместите двоеточие после списка аргументов в конструкторе. Затем вставьте один или несколько инициализаторов членов через запятую.

Инициализатор членов позволяет устанавливать значения константных полей во время выполнения.

Все инициализации члена выполняются перед телом выполнения конструктора. Здесь есть два преимущества:

- Обеспечивает правильность всех элементов перед выполнением конструктора поэтому можно сосредоточиться на логике инициалиации, а не на проверке ошибок членов.
- Члены инициализуруются один раз. Если член переопределяются в конструкторе, вы потенциально можете выполнить доп работу.

```cpp
class S {
	int int_s;
	bool bool_s;
public:
	S(int n, bool a) : int_s{ n }, bool_s{ a } {}  
}
```

### Вывод типов с помощью auto

Ключевое слово auto указывает компилятору предсказать тип объекта, освобождая нас от избыточного ввода информации.

Очень помогает при работе с итераторами в контейнерах.

>[!note] Примечание
>Есть несколько крайних случаев использования инициализации в фигурных скобка, когда могут получиться неожиданные результаты (но их не много), особенно после того, как С++17 исправил некоторые бессмысленные действия. До С++17 использование auto с фигурными скобками {} определяло специальный объект с именем std::initializer_list
>

## Жизненный цикл объекта

Жизненный цикл объекта - это серия этапов, который объект С++ проходит за всю свою жизнь.

### Длительность хранения объекта

Объект - это область хранения, которая имеет тип и значение. При объявлении переменной создаётся объект. Переменная - это просто объект с именем.

#### Выделение, освобождение и срок службы

Каждый объект требует хранения. Хранилище для объектоврезервируется в процессе, называемом *распределением*. Когда объект больше не нужен, хранилище объекта освобождается в процессе, называемом *освобождением*.

*Длительность ханения* объекта начинается, когда объект выделяется, и заканчивается, когда объект освобождается. *Время жизни* объекта - это свойство времени выполнения, которое ограниченно длительностью хранения объекта. Время жизни объекта начинается после завершения его конструктора и закначивается, когда вызывается деструктор. Таким образом,каждый объект проходит следующие этапы:

1. Начинается срок хранения объекта и выделение хранилища.
2. Вызывается конструктор объекта
3. Начинается время жизни объекта
4. Объект можно использовать в программе
5. Срок службы заканчивается
6. Вызывается деструктор объекта
7. Срок хранения объекта хаканчивается, и его хранилище высвобождают.


#### Автоматическая длительность хранения

Заключается в том, что *автоматический объект* выделяется в начале вмещающего кодового блока и освобождается в конце. Ограждающий блок - область видимости автоматического объекта.

#### Статическая длительность хранения

*Статический объект* объявляется с использованием ключевого слова *static* и *extern*. Статические переменные объявляютс на том же уровне, что и функции, -  в лобальной области (или в области *пространсва имён*). Статический объект с глобальной областью видимости имеет *статическую длительность хранения*, распределяются при запуске программы и освобождается при её завершении.

```cpp
#include <iostream>  

static int rat_thing_power = 200; 
  
void power_up_rat_thing(int nuclear_isotopes) {   
    rat_thing_power += nuclear_isotopes;  
    const auto waste_heat = rat_thing_power * 20;  
    if (waste_heat > 10'000) {  
        std::cout << "Warning!\n";  
    }  
    std::cout << "Rat-powe: " << rat_thing_power << std::endl;  
}  
  
int main() {  
    power_up_rat_thing(100);  
    power_up_rat_thing(500);  
}
```

При использовании ключевого слова static мы указываем внутреннюю связь. Внутрення связь означает, что переменная недоступна для других программных едениц. Можно поочерёдно указать внешнюю связь, которая делает переменную доступной для других программных едениц. Для внешних связей используется ключевое слово extern вместо static. 

#### Локальная статическая переменная

Локальная статическая переменная - это особый вид переменной, которая является локальной, а не глобальной. Локальные статические переменные объявляются в области действия функции как автоматические. Но их срок жизни начинается после первого вызова включающей функции как автоматические. Но их срок жизни начинается после первого вызова включающей функции и заканчивается при выходе из программы.

```cpp
#include <iostream>  
  
void power_up_rat_thing(int nuclear_isotopes) {  
    static int rat_thing_power = 200;  
    rat_thing_power += nuclear_isotopes;  
    const auto waste_heat = rat_thing_power * 20;  
    if (waste_heat > 10'000) {  
        std::cout << "Warning!\n";  
    }  
    std::cout << "Rat-powe: " << rat_thing_power << std::endl;  
}  
  
int main() {  
    power_up_rat_thing(100);  
    power_up_rat_thing(500);  
}
```

То есть мы можем перенести static int  (Например) в саму функцию и значение будет сохраняться.

Такой пример шаблона называется *инкапсуляцией* он защишает от непредномеренного изменения данных из вне.

#### Статические члены

*Статические члены* являются членами класса, которые не связаны с конкретным экземпляром класса. Обычные члены класса имеют время жизни, вложенное в срок жизни класса, но статические члены имеют статическую длительность хранения.

Эти члены в основном похожи на статические переменные и функции, объявленные в глобальной видимости; однаконужно обращаться к ним по имени содержащего класса , используя оператор разрешения контекста ::. Фактически нужно инициализировать статические члены в глобаной области видимости. Нельзя инициализировать статический член внутри содержащего определения класса.

```cpp
#include <iostream>  
struct Rating {  
    static int rat_thing_power;  
    static void power_up_rat_thing(int nuclear_isotopes) {  
        rat_thing_power += nuclear_isotopes;  
        const auto waste_heat = rat_thing_power * 20;  
        if (waste_heat > 10'000) {  
            std::cout << "Warning!\n";  
        }  
        std::cout << "Rat-powe: " << rat_thing_power << std::endl;  
    }  
};  
  
int Rating::rat_thing_power = 200;  
  
int main() {  
    Rating::power_up_rat_thing(100);  
    Rating::power_up_rat_thing(500);  
}
```

#### Локальная потоковая длительность хранения

Одиним из фундаментальных в программировании является *поток*. Каждая программа имеет один или несколько потоков, которые могут выполнять независимые операции. Последовательность инструкций, которые выполняет поток, называется его *потоком выполения*.

Код должен быть безопасен. Код, который могут безопасно использовать несколько потоков называется поточно-ориентированным кодом.

Чтобы избежать неприятностей с переменными глобальной видимости, это можно сделать, указав, что объект имеет *потоковую длительность хранения*.

Чтобы изменеить любую переменную со статической длительности хранерия нужно добавить слово thread_local к ключевому слову static или extern. Если указан только thread_local, то предпологается использование static.

#### Динамическая длительность хранения

Память для объектов *динамической длительности хранения* выделяется и освобождается по запросу. Программист может применить ручное управлениеначалом и завершением жизни *динамического объекта*.

```cpp
int* my_int_ptr = new int;
int* my_int_ptr = new int{ 42 };

delete my_int_ptr;

Mytype* my_init = new MyType[n_elements] {init-list};

delete[] my_init;
```

#### Утечки памяти

Нужно убедиться, что выделенная динамически память освобожденна. Иначе могут возникнуть утечки.

### Исключения

*Исключение* - это типы сообщающик об ошибке. При возникновении ошибки *генерируется* исключение. После того как исключение было сгенерировано, оно переходит в *состояние полёта*. Когда исключение находится в состоянии полёта, программа останавливает нормальное выполнение и ищет *обработчик исключение*, который может управлять исключениями в полёте. Объекты, которые выпадают из области видимости во время процесса, уничтожаются.

Другой вариант оповещения об ошибках - это возврат кода ошибки как части прототипа функции. Эти два подхода дополняют друг друга. В ситуациях, возникает ошибка, с которой можно справиться локально или которая должна произойти во время нормального хода выполнения программы, обычно возвращается код ошибки.

#### Ключевое слово throw

Чтобы вызвать исключение используется *throw*, за которым следует бросаемый объект.

Большинсвто объектков являются бросаемыми. Однако рекомендуется использовать одно из исключений, доступных в stdlib, например std::runtime_error в заголовке **stdexept**

```cpp
#include <stdexcept>  
#include <cstdio>  
  
struct  Groucho {  
    void forget (int x) {  
        if (x == 0xFACE) {  
            throw std::runtime_error{"i'd be glad to make a exeption"};  
        }  
        printf("0x%x\n", x);  
    }  
};
```

#### Использование блоков try-catch

Блоки try-catch используются для установки обработчиков исключений в блоке кода. Внутри блока try размещается код, который может вызвать исключение. Внутри catch указатель обработчик для каждого типа исключений, который можно обработать.

```cpp
#include <stdexcept>  
#include <cstdio>  
  
struct  Groucho {  
    void forget (int x) {  
        if (x == 0xFACE) {  
            throw std::runtime_error{"i'd be glad to make a exeption"};  
        }  
        printf("0x%x\n", x);  
    }  
}; 
  
int main() {  
    Groucho groucho;  
    try {  
        groucho.forget(0xC0DE);  
        groucho.forget(0xFACE);  
    } catch (const std::runtime_error& e) {  
        printf("exeption caught with message: %s\n", e.what());  
    }  
}
```

По итогу исключение бросится на строчке `groucho.forget(0xFACE);` закончит нормальное выполение forget и пойдём в блок catch.

### Классы исключений stdlib

Наследование оказвает большое влияние на то, как код обрабатывает исключения.

#### Стандартные классы исключений

stdlib предоставляет *стандартные классы исключений* в заголовке **std::exception**. Являетсяя базой для построения исключений. Супер классом для всех стандартных исключений является **std::exception**. Все подкалссы в **std::exception** могут быть разделенны на три группы: логические ошибки (logical_error), ошибки выполнения (runtime_error) и ошибки языковой поддержки (не относятся к нам как к программисту).

![[exception.jpg]]

#### Обработка исключений
 
Правило обработки исключений основаны на наследовании классовю Когда выбрасывается исключение, блок catch обрабатывает его, если тип выброшенного исключения соотвествует типу исключения обработчика или есть тип выброшенного исключения наследуются от типа исключения обработчика.

Например обработчик может перехватывать любое исключение наследуемое от **std::exception**, включая std::logical_error

```cpp
try {  
    // код который может выдать исключение  
} catch (const std::logic_error& ex) {  
    // запись исключения и завершение работы программы4 найденна программная ошибка!  
} catch (const std::runtime_error& ex) {  
    // Делаем всё что можно  
} catch  (const std::exception& ex) {  
    // Обработка любого исключения наследуемого от std::exception  
    // которое не является logic_error или runtime_error 
} catch () {  
    // Паника было сгенерированно не предвиденное исключение  
}
```

#### Пользовательские исключения

Программсит обычно может определить свои пользовательские исключения; обычно они наследуются от **std::exception**. Все классы из stdlib используют исключения, которые происходят от **std::exception**. Это позволяет легко перехватить все исключения, будь то из ващего кода или из stdlib, с помощью одного блока catch.

#### Ключевое слово noexcept

Можно и нужно пометить лубую функцию, которая в теории не может вызвать исключение, ключевым словом noexcept.

```cpp
bool is_odd(int x) noexcept {
	return 1 == (x % 2);
}
```

Функции с пометкой noexcept можно быть уверенным что функция не может вызвать исключение. 

#### Исключение и стек вызова

*Стек вызова* - это структура времени выполнения, в которой хранится информация об активных функциях. Когда часть кода(*вызывающая сторона*)вызывает функцию(*вызываемая сторона*), машина отслеживает, кто когда вызвал, помещая информацию в стек вызывов.

#### Стеки вызова и обработка искючений

Среда выполнения ищет ближайщий обработчик исключений для выброшенного исключения. Если в текущем кадре стека есть сотвествующий обработчик исключения он его обработает. Если соотвествующий обработчик не найден, среда выполнения раскучивает стек вызова, пока не найдёт подходящий обработчик. Любой объект срок жизни заканчивает, уничтожаются обычным способом.

#### Выбрасывание исключений из деструктора

Выбрасывание исключений из деструктора - это жонглирование бензопилами. Такое исключение обязательно должно быть поймано внутри деструктора.

Как правило с деструкторами нужно обращаться так как будто они были бы noexcept.

### Семантика копирования

*Семантика копирования* - это "смысл копирования". На практике программисты используют этот термин для обозначения правил создания копий объектво: после того как *x скопирован в y*, они *эквивалентны* и *независимы*. То есть x == y имеет значение *true* после копирования (эквивалентность), а изменение x не вызывает изменения y (независимость). Копирование черезвычайно распространено, особенно при передаче объектов в функции по значению.

Полнофункциональные классы требуют больше размышлений. Семантика копирования для полнофункциональных классов также является копией для каждого элемента, и это может быть черезвычайно опасно. Рассмотри класс SimpleString. Произошла бы котострофа, если бы позволили пользователю сделать поочерёдную копию живого класса *SimpleString*. Два класса *SimpleString* будут указывать на один и тот же *buffer*. Поскольку обе копии добавляются в один и тот же *buffer*, они сотрут друг друга.

![[copy_simplestring.jpg]]

Такой результат плох, но ещё хуже, если классы *SimpleString* начинаются уничтожаться. Когда один из классов *SimpleString* будет уничтожен, буфер освободится. Когда оставшийся класс *SimpleString* пытается записать свой буфер - бабах! - возникнет неопределённое поведение. В какой-то момент этот оставшийся класс *SimpleString* будет разрушен и буфер снова освободится, что приведёт к так называемому двойному освобождению.

Если взять под контроль семантику копирования, такой ситуации можно избежать. Укажите конструкторы копирования и операторы копирования, как описанно в следующих разделах.

#### Конструктор копирования

*Конструктор копирования* создаёт копию и присваивает её совершенно новому объекту. Конструктор копирования выглядит, как другие конструкторы.

```cpp
struct SimpleString {
	--пропуск--
	SimpleString(const SimpleString& other);
}
```

Обратите внимания, что other имеет пометку const. Для того чтобы скопировать оригинал и не применять для него изменения.

Давайте реализуем конструктор копирования SimpleString. Необходима так называемая глубокая копия, когда данные, на которые указывает исходный буфер, копируются в новый буфер.

Вместо того чтобы копировать указатель buffer, создадим новое выделение памяти в свободное хранилище, а затем скопируем все данные, на которые указывает исходный буфер. В результате получим два исходных класса SimpleString.

Влияние копирования на производительность может быть значительным, особенно в ситуации, когда задействовано выделения памяти и копии буфера.

#### Присваивание копии

Другой способ сделать копии в С++ - использовать *оператор присваивания копии*.

Строка копирования одного объекта класса к другому `b = a`, *копирует присваивание* a в b и может вызвать не определённое поведенение, поскольку в нём отсуствует пользовательский оператор копирования присваивания. Основным различием между присваиванием копии и созданием копии состоит в том, что при присваивании копии b может уже иметь значение. Нужно очистить ресурсы b перед копированием в a.

>[!note] Примечание
>По умолчанию оператор присваивания копии для простых типов просто копирует элементиз исходного объекта в целевой. Вслучае с SimpleString это очень опасно по двум причинам. Во-первых, буфер исходного класса SimpleString перезаписывается без освобождения динамически расширяемого массива char. Во-вторых, теперь два класса SimpleString имеют один и тоже буфер, что может привести к висячим указателям и двойным освобождениям. Нужно реализовывать оператор присваивания копии, который выполняет чистую передачу.

Оператор присваивания копии использует синтаксис operator=.

Оператор присваивания копии возвращает ссылку на результат, который всегда имеет значение _*this_. Также обычно рекомендуется проверять, ссылается ли other на this.

Можно реализовать присваивание копии для SimpleStrin, следую этим рекомендациям: освободите buffer от this, а затем скопируйте other, как вы это делали при использовании конструктора копирования.

```cpp
SimpleString& operator=(const SimpleString& other) {  
    if (this == &other) return *this;  
    const auto new_buffer = new char[other.max_size];  
    delete[] buffer;  
    buffer = new_buffer;  
    lenght = other.lenght;  
    max_size = other.max_size;  
    std::strncpy(buffer, other.buffer, max_size);  
    return *this;  
}
```
#### Копирование по умолчанию

Часто компилятор генерирует реализацию по умолчанию для конструктора копирования и присваивания копии. Реализация по умолчанию - вызывать конструктор копирования или присваивание копии для каждого из члена класса. Каждый раз, когда класс управляет русурсом, нужно быть черезвычайно осторожным с сменатикой копирования по умолчанию; скорее всего, класс ошибается. Соглассно рекомендациям, нужно явно объявить, что присваивание копии и конструктор копирования по умолчанию приемлемы для таких классов с использованием ключевого слова default. Например, класс Replicant имеет семантику копирования по умолчанию, как показано здесь:

```cpp
struct Replicant {  
    Replicant(const Replicant&) = default;  
    Replicant& operator=(const Replicant&) = default;  
};
```

Некоторые классы просто не могут или не должны копировать - например, если класс управления файлов или если он представляет собой блокировку исклбчения для параллельного програмирования. Можно запретить компилятору генерировать конструктор копирования и оператор присваивания копии, используя ключевое слово delete. Например, класс Highlander нельзя скопировать:

```cpp
struct Highlander {  
    Highlander(const Highlander&) = delete;  
    Highlander& operator=(const Highlander&) = delete;  
};
```

Любая попытка скопировать Highlander приведёт к ошибке компилятора.

>[!note] Рекомендация
>Настоятельно рекомендую явно определить присваивание копии и конструктор копирования для любого класса, которому приндлежит ресурс (например, принтер, сетевое соединение или файл). Если пользовательское поведение не требуется, используйте либо default, либо delete. Это избавит вас от множества неприятных и трудных для отладки ошибок.

### Руководство по копированию

При реализации поведения копирования стоит подумать о следующих критериях:

- **Коректность**. Нужно убедиться, что инварианты классов поддерживаются. Класс SimpleString продемонстрировал, что конструктор копирования по умолчанию может нарушать инвалидацию.
- **Независимость**. После присваивания копии или конструктора копирования исходный объект и копия не должны изменять состояние длруг друга во время модификации.
- **Эквивалентность**. Оригинал и копия должны быть *одинаковыми*. Семантика одинаковости зависит от контекста. Но, как правило, операция, примененная к оригиналу должна давть тот же результат

### Семантика перемещения

Копирование может занимать много времени во время выполнения, когда задействован большой объем данных. Часто необходимо просто передать право собственности на ресурсы с одного объекта на другой. Можно сделать копирование и уничтожить оригинал, но зачастую это не эфективно. Вместо этого можно *перенести* права на владение.

*Семантика перемещения* - это следствие для семнтики копирования, и она требует, чтобы после того, как объект y был *перемещён* в объект x, x был эквивалентен предыдущему значению y. После переноса y находится особом состояни, которое называется *состояние перемещения*. Можно выполнить только две операции над перемещениями объектами: (пере)назначить или уничтожить их.  Обратите внимение, что перемещение объекта y в объект x - это не просто переименование: это отдельные объекты с отдельными хранилищем и потенциально отдельным временем жизни.

Подобно тому как задаётся конструктор копирования, нужно указать, как объекты перемещаются с помощью *конструктора переноса* и *операторов присваивания перемещения*.

#### Копирование может быть расточительным

Предположим, нужно переместить SimpleString в SimpleStringOwner следующим образом:

```cpp
SimpleString a{50};
SimpleStringOwner b{a};
```

Можно добавить конструктор для SimpleStringOwner, а затем скопировать-сконструировать его член.

```cpp
struct SimpleStringOwner {
	SimpleStringOwner(const SimpleString& my_string) : string{my_string} {}
private:
	SimpleString string;
}
```

у этого подхода есть сткрытые издержки. У нас есть конструкция копирования, но вызывающая сторона никогда не использует объект, на который указывает указатель, после создания string.

Вы должны переместить начинку SimpleString a в строковое поле SimpleStringOwner. Необходимо достичь: SimpleStringOwner b захватывает buffer и переводит SimpleString a в состояние уничтожения.

#### Категории значений

Каждое выражение имеет две важные характеристики: его *тип* и
*категорию значения*. Категории занчения описывает, какие виды операций допустимы для выражения. Благодаря эволюционному характеру С++ категории значений являются сложными: выражение может быть "обобщённым l-значением" (gl-значение), "простым r-значением" (pr-значением), "истекающим значением" (x-значением), "l-значением" (gl-значение, которое не является x-значением) или "r-значением" (pr-значением или x-значением).

Общее понимание. l-значением - это любое значение, которое имеет имя, а r-значение - это все, что не является l-значением.

Рассмотрим следующие инициализации:

```cpp
SimpleString a{50};
SimpleString b {a}; // a - l-значение
SimpleString c { SimpleString{50} }; // SimpleString{50} - r-значение
```

Этимология этих терминов - это *правое (right) значение и левое (left) значение*, отоносящиеся к тому, где они появляются по отношению к знаку равенста в конструкции. В утверждении int x = 50; x находится слева от знака равенства (l-значение), а 50 - справа от знака равенства (r-значение). Эти термины не совсем точны, потому что l-значение может находится справа от знака раенства.

#### Ссылки на l-значния и r-значения

Можно сообщить компилятору, что функции примает l-значния или r-значения, используя ссылка на l-значния(обозначается &) и r-значения(обозначается &&).

```cpp
void ref_type(int &x) {  
    std::cout << "l: " << x << std::endl;  
}  
  
void ref_type(int &&x) {  
    std::cout << "r: " << x << std::endl;  
}
```

#### Функция std::move

Можно перевести ссылку на l-значние к ссылке на r-значение, используя фунцию std::move.

Если под рукой находится l-значние, перенос отменяется. Если используется r-значение, перенос разрешён.

#### Конструктор переноса

Конструктор переноса выглядят как конструктора копирования, за исключением того, что они принимают ссылки на r-значение вместо ссылок на l-значения.

```cpp
SimpleString(SimpleString&& other) noexcept : max_size(other.max_size),  
    buffer(other.buffer),  
    lenght(other.lenght) {  
    other.lenght = 0;  
    other.buffer = nullptr;  
    other.max_size = 0;  
}
```

Поскольку other - это ссылка на r-значение, разрешено её уничтожить. В случае с SimpleString это легко: просто скопируйте все поля other в this, а затем обнулите поля other. Последний шаг важен:он переводится other в перемещенное состояние.

Выполнение этого конструктора переноса намного дешевле, чем выполнение конструктора копирования.

Конструктор переноса разработан так, чтобы не создавть исключение, поэьтому он помечается как noexcept. Предпочтительно использовать noexcept конструкторы переноса; часто компилятор  не может использовать конструктор переноа, генерирующий исключения, и вместо это будет использовать конструкторы копирования. Компилятору предпочтительнее более медленный код но правильный, чем более быстрый и неправильный.

#### Присваивание перемещения

Также можно создать аналог перемещения для присванивания копии с помощью operator=.

Подумайте, что было бы, если std::move не был нужен? Что, если бы вы переместились из x, а затем использовали бы его внутри конструктора? Это может привести к ошибкам, которые трудно диагностировать. Помните, что нельзя использовать перемещённые объекты никоим образм, кроме как для переназначения их или уничтожения. Делать что-либо ещё - неопределённое поведение.

#### Конечный продукт

```cpp
struct SimpleString {  
    SimpleString(size_t max_size) : max_size{ max_size }, lenght{} {  
        if (max_size == 0) {  
            throw std::runtime_error{ "Max size must be at least 1." };  
        }  
        buffer = new char[max_size];  
        buffer[0] = 0;  
    }  
  
    SimpleString(const SimpleString& other) : max_size(other.max_size), buffer(new char[other.max_size]),  
    lenght(other.lenght) {  
        std::strncpy(buffer, other.buffer, max_size);  
    }  
  
    SimpleString& operator=(const SimpleString& other) {  
        if (this == &other) return *this;  
        const auto new_buffer = new char[other.max_size];  
        delete[] buffer;  
        buffer = new_buffer;  
        lenght = other.lenght;  
        max_size = other.max_size;  
        std::strncpy(buffer, other.buffer, max_size);  
        return *this;  
    }  
  
    SimpleString(SimpleString&& other) noexcept  
    : max_size(other.max_size),  
        buffer(other.buffer),  
        lenght(other.lenght) {  
        other.lenght = 0;  
        other.buffer = nullptr;  
        other.max_size = 0;  
    }  
  
    SimpleString& operator=(SimpleString&& other) noexcept {  
        if (this == &other) return *this;  
        delete[] buffer;  
        buffer = other.buffer;  
        lenght = other.lenght;  
        max_size = other.max_size;  
        other.buffer = nullptr;  
        other.lenght = 0;  
        other.max_size = 0;  
        return *this;  
    }  
  
    void print(const char* tag) const {  
        printf("%s: %s", tag, buffer);  
    }  
  
    bool append_line(const char* x) {  
        const auto x_len = strlen(x);  
        if (x_len + lenght + 2 > max_size) return false;  
        std::strncpy(buffer + lenght, x, max_size - lenght);  
        lenght += x_len;  
        buffer[lenght++] = '\n';  
        buffer[lenght] = 0;  
        return true;  
    }  
  
    ~SimpleString() {  
        delete[] buffer;  
    }  
  
private:  
    size_t max_size;  
    char* buffer;  
    size_t lenght;  
};
```
#### Методы генирируемые компилятором

Пять методов управляемы поведением переноса и копирования:

- деструктор
- конструктор копирования
- конструктор переноса
- оператор присваивания копии
- оператор присваивания переноса

Компилятор может генерировать реализации по умолчанию для каждого из них при определённых обстоятельствах. К сожалению, правила, для которых генерируются методы, являются сложными и потенциально неравномерными в разных компиляторах.

Можно устранить эту сложность установив для этих методов default/delete или применив их соответствующим образом. Это общее правило - правило пяти,потому что существует пять специальных методов.

## Полиморфизм во время выполнения

### Полиморфизм

*Полиморфный код* - это код, который пришется один раз и который можно использовать для разных типов. В конечном, счёте эта гибкость представляет слабосвязанный и многократно используемый код. С++ предлагает два ролиморфных подхода. Полиморфный код во время копиляции включает полиморфные типы, которые можно определить *во в время компиляции*. Другой подход - *полиморфизм во время выполнения*, который вместо этого включает типы, определяемые выполнения.

#### Интерфейсы

В программной инженирии *интерфейс* - это общая граница, которая не содержит данных или кода. Он представляет сигнатуру функций, которые согласны поддержитвать все реализации интерфейса. *Реализация* - это код или данные, которые декларируют поддержку интерфейса. Можно представить интерфейс как договор между классами, которые реализуют интерфейс, и пользователями (так называемыми *потребителями*) этого класса.

Интерфейсы предъявляют жёсткие требования. Потребитель интерфейса может использовать только методы, явно определённые в интерфейсе.

#### Композиция объектов и реализация наследования

*Композиция объектов* - это шаблон проектирования, в котором класс содержит члены других типов классов. Альтернативный устаревший шаблон проектирования, называемый *наследованием реализации*, обеспечивает полиморфизм во время выполения. Наследование реализации позволяет строить иерархии классов; каждый дочерний класс наследует функциональность от своих родителей. 


### Определение интерфейсов

В С++ нет ключевого слова interface. Интерфейсы нужно определять, используя устаревшие механизмы наследования.

**Интерфейс Logger и переработанный ConsoleLogger**

```cpp
struct Logger {  
    virtual ~Logger() = default;  
    virtual void log_transfer(long from, long to, double amount) = 0;  
};  
  
struct ConsoleLogger : Logger {  
    void log_transfer(long from, long to, double amount) override {  
        std::cout << from << "->" << to << ": " << amount << std::endl;  
    }  
};
```

#### Базовое наследование классов

В главе [про исключения(exception)](#Стандартные%20классы%20исключений) является базовым классом для всех других исключений *stdlib* и как классы *logic_error* и *runtime_error* наследуют от *exception*. Эти два класса в свою очередь, образуют баззовые классы для других производных классов, которые описывают условия ошибок более подробных, например *invalid_argument* и  *system_error*.  Вложенные классы исключений образуют пример иерархии классов и представляют собой дизайн наслеования реализации.

Производные классы объявляются с использованием следующего синтаксиса.

```cpp
struct DerivedClass : BaseClass {
 --some code--
};
```

Чтобы определить отношения наследования для *DerivedClass*, используется двоеточие (:), за которым следует имя бозового класса *BaseClass*. 

Производные классы объявляют так же, как и любой другой класс. Преимущество заключается в том, что можно обрабатывать ссылки на производные классы так, как если бы они имели ссылочный тип базового класса. Пример кода наиже использует ссылку на класс наследник вместо базового класса.

```cpp
struct BaseClass {};
struct DerivedClass : BaseClass {};
void are_belong_to_us(BaseClass& base) {}

int main() {
	DerivedClass derived;
	are_belong_to_us(derived);
}
```

*DerivedClass* является производным от *BaseClass*. Функция *are_belong_to_us* принимает фргумент-ссылку на *BaseClass* - base.Ее можно вызвать из экземпляра *DerivedClass*, потому что *DerivedClass* является  производным от *BaseClass*. Обратное не верно (потому что базовый класс не знает о наследуемом).

#### Наследование членов

Производные классы наследуют неприватные члены от своих базовых классов. Классы могут использовать унаследованные члены как обычные члены. Предполагаемое преимущество наследования состоит в том, что можно определить функциональность один раз в базовом классе и не повторять ее в производных классах. К сожалению, опыт убедил многих в сообществе программистов избегать наследования членов, потому что он может легко привести к хрупкому, трудному для понимания коду по сравнению с полиморфизмом на основе композиции.

#### Методы virtual

Если необходимо разрешить производному классу переопределить методы базового класса, используйте ключевое слово virtual (виртуальный). Добавляя virtual в определение метода, вы объявляете, что должна использоваться реализация в производном классе, если она предоставлена. В рамках реализации нужно добавить ключевое слово override в объявление метода, как показано в коде ниже.

BaseClass содержит виртуальный член. В *DerivedClass* переопределяется унаследованный элемент с использованием ключевого слова override. Реализация BaseClass используется только тогда, когда экземпляр BaseClass находится под рукой. Реализация DerivedClass используется, когда присуствует экземпляр DerivedClass, даже если взаимодействие с ним осуществляется через ссылку BaseClass.

```cpp
struct BaseClass {  
    virtual const char* final_massage() const {  
        return "We apologize for the incontinence.";  
    }  
};  
  
struct DerivedClass : BaseClass {  
    const char* final_massage() const override {  
        return "We apologize for the incontinence.";  
    }  
};  
  
int main() {  
    BaseClass base;  
    DerivedClass derived;  
    BaseClass& ref = derived;  
    std::cout << base.final_massage() << std::endl;  
    std::cout << derived.final_massage() << std::endl;  
    std::cout << ref.final_massage() << std::endl;  
}
```

>Out:
>We apologize for the incontinence.
>We apologize for the incontinence.
>We apologize for the incontinence.

Если нужно, чтобы производный класс реализовал метод, можно добавить суфикс =0 к определению метода. Методы вызываются как с ключевым словам virtual, так и с суффиксом =0 для чисто виртуальных методов. Нельзя создать экземпляр класса, содержащий какие-либо чисто виртуальные методы.

```cpp
struct BaseClass {  
    virtual const char* final_massage() const = 0;  
};  
  
struct DerivedClass : BaseClass {  
    const char* final_massage() const override {  
        return "We apologize for the incontinence.";  
    }  
};  
  
int main() {  
    // BaseClass base; // бах!
    DerivedClass derived;  
    BaseClass& ref = derived;  
    std::cout << "DerivedClass: " << derived.final_massage() << std::endl;  
    std::cout << "BaseClass&: " << ref.final_massage() << std::endl;  
}
```

>DerivedClass: We apologize for the incontinence.
>BaseClass&: We apologize for the incontinence.

Суффикс =0 указывает на чисто виртуальный метод, то есть нельзя создавать экземпляр BaseClass - только производные от него. DerivedClass по-прежнему наследуется от BaseClass, и предоставляется необходимый final_message. Попытка создания экземпляра BaseClass приведёт к ошибке компилятора. И DerivedClass и ссылка BaseClass ведут себя, как и раньше.

#### Чисто виртуальные классы и вритуальные деструкторы

 Наследования интерфейса достигается путем наследования из базовых классов, которые содержат только чисто виртуальные методы. Такие классы называются чисто виртуальными классами. В С++ интерфейсы всегда являются *чисто виртуальными классами*. Обычно виртуальные деструкторы добавляются в интерфйесы. В некоторых редких случаях возможна утечка ресурсов, если не пометить деструкторы как виртуальные. В коде ниже приведен пример, показывающий опасность отсуствия виртуального деструктора.

```cpp
struct BaseClass {};  
  
struct DerivedClass : BaseClass {  
    DerivedClass() {  
        printf("Derived invoked.\n");  
    }  
    ~DerivedClass() {  
        printf("~Derived invoked.\n");  
    }  
};  
  
int main() {  
    printf("Constructing Derived.\n");  
    BaseClass* x{ new DerivedClass{} };  
    printf("deleting x as Derived.\n");  
    delete x;  
}
```

>Constructing Derived.
 Derived invoked.
 deleting x as Derived.

Здесь вы видите DerivedClass, производны от BaseClass. Этот класс имеет конструктор и деструктор, которые выводят сообщения при вызове. Внутри main размещается и инициализируется DerivedClass c помощью new, а результат устанавливается в указатель BaseClass. При удалении указателя вызовется деструктор BaseClass, но деструктор DerivedClass этого не делает.

Добавление виртуального деструктора в BaseClass решает проблему, как показанно ниже.

```cpp
struct BaseClass {  
    virtual ~BaseClass() = default;  
};  
  
struct DerivedClass : BaseClass {  
    DerivedClass() {  
        printf("Derived invoked.\n");  
    }  
    ~DerivedClass() {  
        printf("~Derived invoked.\n");  
    }  
};  
  
int main() {  
    printf("Constructing Derived.\n");  
    BaseClass* x{ new DerivedClass{} };  
    printf("deleting x as Derived.\n");  
    delete x;  
}
```

>Constructing Derived.
 Derived invoked.
 deleting x as Derived.
 ~Derived invoked.

Добавление виртуального деструктора приводит к тому, что деструктор DerivedCalss вызывается при удалении указателя BaseClass, в результате чего деструктор DerivedCalss выводит сообщение.

Объявление виртуального деструктора необязательно при объявлении интерфейса, но будьте осторожны. Если вы забудуте, что не реализовали виртуальный деструктор в интерфесе, и случайно сделали что-то вроде ошибочного кода выше(через один), ресурсы могли быть утеренны, а компилятор не предупредит об этом.

> [!note] Примечание
> Объявление защищённого *невиртуального* деструктора является альтернативой объявлению публичного *виртуального* деструктора, поскольку это приведёт к ошибе компиляции при написании кода, удаляющего указатель бозового класса. Некоторым не нравится этот подход, потому что в конечном итоге придется создать класс с публичным деструктором и при наследовании этого класса возникнут те же проблемы.

#### Реализация интерфейсов

Чтобы объявить интерейс, объявите чисто виртуальный класс. Чтобы реализовать интерфейс, наследуйте от него. Поскольку интерфейс является чисто виртуальным, реализация должна использовать все методы интерфейса.

Рекомендуется помечать эти методы ключевым словом override. Это говорит о намерении переопределить виртуальную функцию, что позволяет компилятору избавить разработчика от простых ошибок.

#### Использование интерфейсов

Потребитель может иметь дело только со ссылками или указателеями на интерфейсы. Компилятор не может заранее знать, сколько памяти выделить для базового типа; если компилятор может знать базовый тип, лучше использовать шаблоны. Существуют  два варианта настройки элемента:
- **внедрение через конструктор.** Внедрение через конструктор обычно использует ссылку на интерфейс. Поскольку ссылки не могут быть повтороно установлены, они не будут меняться в течении всего срока жизни объекта;
- **внедрение через свойства.** Внедрение через свойство позволяет использовать метод для указания члена-указателя. Это позволяет изменить объект, на который направлен указатель.
Можно комбинировать эти подходы, принимая указатель интерфейса в конструкторе, а также предоставляя метод для установки указателя на что-то другое.

Как правило вы будете использовать внедрение через конструктор, когда введенное поле не изменится в чечение всего срока службы объекта. Если нужна гибкость изменения поля, предоставьте методы для внедрения через свойство.

### Обновление банкового регистратора

```cpp
struct Logger {  
    virtual ~Logger() = default;  
    virtual void log_transfer(long from, long to, double amount) = 0;  
};  
  
struct ConsoleLogger : Logger {  
    void log_transfer(long from, long to, double amount) override {  
        std::cout << "[cons]" << from << "->" << to << ": " << amount << std::endl;  
    }  
};  
  
struct FileLogger : Logger {  
    void log_transfer(long from, long to, double amount) override {  
        std::cout << "[file]" << from << "," << to << "," << amount << std::endl;  
    }  
};
```

Logger - это чисто виртуальный класс (интерфейс) с виртуальным деструктором и по умолчанию и единственным методом log_transfer. ConsoleLogger и FileLogger являются реализациями Logger, поскольку они - производные от интерфейса. Вы реализовали log_transfer и поместили ключеовое слово override в оба.

Теперь раасмотрим, как можно использовать внедрение через конструктор или свойства для обновления Bank.

#### Внедрение через конструктор

Используя внедрение через конструктор, вы получаете ччылку на Logger, которая передаётся в конструктор класс Bank.

```cpp
struct Bank {  
    Bank(Logger &logger) : logger{ logger } { }  
  
    void make_transfer(long from, long to, double amount) {  
        // space  
        logger.log_transfer(from, to, amount);  
    }  
private:  
    Logger& logger;  
};  
  
int main() {  
    ConsoleLogger logger;  
    Bank bank{logger};  
    bank.make_transfer(1000, 2000, 49.95);  
    bank.make_transfer(2000, 4000, 20.00);  
  
}
```

>[cons] 1000->2000: 49.95
 [cons] 2000->4000: 20

Конструктор класса Bank устанавливает значение logger с использованием инициализации члена. Ссылки не могут быть повторно установлены, поэтому объект, на который указывает logger, не изменяется в течение всего срока существования Bank. Выбор регистратора фиксируется при создании экземпляра Bank.

#### Внедрение через свойство

Вместо использования конструктора для вставки Logger в Bank можно использовать внедрение через свойство. Этот подход использует указатель вместо ссылки. Поскольку указатели могут быть переопределены (в отличие от сылок), можно изменить поведение Bank в любой момент.

```cpp
struct Bank {  
    void set_logger(Logger* new_logger) {  
        logger = new_logger;  
    }  
  
    void make_transfer(long from, long to, double amount) {  
        if (logger) logger->log_transfer(from, to, amount);  
    }  
private:  
    Logger* logger;  
};  
  
int main() {  
    ConsoleLogger console_logger;  
    FileLogger file_logger;  
    Bank bank;  
    bank.set_logger(&console_logger);  
    bank.make_transfer(1000, 200, 49.95);  
    bank.set_logger(&file_logger);  
    bank.make_transfer(2000, 4000, 20);  
}
```

>[cons] 1000->200: 49.95
>[file] 2000,4000,20

Метод set_logger позволяет вводить новый регистратор в объект Bank в любой точке жиненого цикла. При задании регистратора как экземпляра ConsoleLogger мы получаем префикс [cons] в выходном журнале. При задании регистратора как FileLogger мы получаем префикс [file].

#### Выбор между внедрением через конструктор или свойство

Выбор внедрения через конструктор или свойство зависит от требований к дизайну. **Если важно изменять базовые типы элементов объекта на протяжении всего жизненного цикла объекта, следует выбрать указатель и метод внедрения через свойство.** Но гибкость использования указателей и внедрения через свойство обходится дорого. В примере с банком Bank необходимо убедиться, что в logger не было установленно значение nullptr, либо проверить это условие перед использованием logger. Существует также вопрос о поведении по умолчанию: каково начальное значение logger?

### Доделать часть 1

# Библиотеки и фреймворки

## Тестирование

### Юнит-тестрование

*Юнит-тесты* подтверждают, что целенаправленный, сплочённый набор кода - *модуль* (unit), такой как функция или класс, - ведёт себя именно так как задумал программист.

### Интеграционное тестирование

Тестирование совокупности модулей вместе называется *итеграционным тестированием*. Интеграционное тесты могут также относится к тестированию взаимодействия между программным и аппаратным обеспечением, с которым часто сталкиваются системные программисты. Интеграционные тесты - это важный слой поверх юнит-тестов, поскольку они гарантируют, что написанное программное обеспечение работает вместе как система. Эти тесты дополняют, но не заменяют юнит-тесты.

### Приемочное тестирование

*Приемочные тесты* гарантируют, что ПО соотвествует всем требованиям клиентов. Высокопроизводительные команды разработчиков ПО могут использовать приемочные тесты для руководства разработкой. После того как все приемочные испытания пройдут, ПО будет внедрено. Поскольку эти приемочные тесты становятся частью кодовой базы, существует встроенная защита от рефакторинга или регресии функций - нарушение существующей функции в процессе добавления новой.

### Тестирование производительности

*Тесты производительности* оцениваются, соответствует ли ПО требованиям эффективности, таким как скорость выполнения или потребление памяти/энергии. Оптимизация кода является принципиально эмпирическим упражнением. Вы можете (и должны) иметь представление о том, какие части кода вызывают узкие места в производительности, но не может знать наверняка, если не измерите это. Кроме того, нельзя знать, улучшают ли код изменения, которые вы реализуете с целью оптимизации, пока это не будет измерено снова. 